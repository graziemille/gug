# 567 LAB6
# LANGUAGE: gug / Paraguayan Guaraní
# AUTHOR: Thor Wicke Monteverde
# PARTNER: Lisa Tittle Caballero



1. Matrix yes-no questions 

Guarani uses second position focus markers for matrix yes-no questions, of which there are two. The question clitics =pa or =piko can come after any element in the sentence and make it the focus of a matrix yes/no question. Syntactically both particles behave in the same way, and although there might be some disagreement about the semantics implied by each of them, as explained previously in Lab 4, the difference is irrelevant for our purpose. Following the analysis of our Prof. Bruno Estigarribia, we are treating both particles the same. 

There is also a mismatch between how the two question particles are generally written.  =piko has two syllables and because of some writing conventions requiring affixes to be monosyllabic, it is usually realized as separate word.  =pa has only one syllable and is therefore often glossed as an affix attaching to the preceding word, though it is also sometimes written as a stand alone word.  Based on their shared behavior as outlined above we treat both particles as clitics. 

Here some example IGT showing the use and misuse of these particles.

#Ex.121: Yes-No question with focus marker on verb predicate, and use of marker piko
Source: c
Vetted: f
Judgment: g
Phenomena: {q, wo}
ohecha piko ñakyra  vakápe? 
ohecha piko nNakyra vakaA pe
o-hecha piko nNakyra vakaA=pe
O.3-see Q cricket.ANIM.NOM cow.ANIM=ACC
'Did the cricket see the cow?

#Ex.122: Yes-No question with focus marker on verb predicate, and use of marker pa
Source: c
Vetted: f
Judgment: g
Phenomena: {q, wo}
ohechapa ñakyra vakápe?
ohecha pa nNakyra vakaA pe
o-hecha=pa nNakyra vakaA=pe
O.3-see=Q cricket.ANIM.NOM cow.ANIM=ACC
'Did the cricket see the cow?'

#Ex.116: Yes-No question with question marker in wrong position, grammatical but parses as conjoined separate phrases since pa is constrained to be in second position.
Source: c
Vetted: f
Judgment: g
Phenomena: q
ohecha ñakyrapa vakápe? 
ohecha nNakyra pa vakaA pe
o-hecha nNakyra=pa vakaA=pe
O.3-see cricket.ANIM.NOM=Q cow.ANIM=ACC
'Did the cricket see the cow?

#Ex.117: Yes-No question with question marker in wrong position, should be second position.
Source: c
Vetted: f
Judgment: u
Phenomena: q
ohecha ñakyra vakápepa? 
ohecha nNakyra vakaA pe pa
o-hecha nNakyra vakaA=pe=pa
O.3-see cricket.ANIM.NOM cow.ANIM=ACC=Q
*'Did the cricket see the cow?

Because of our nominal predicates and asyndenton conjunction there are now parses for some of our original ungrammatical strings.  We have reanalyzed the ones that parse with a valid sentence as grammatical with the new reading, but left as ungrammatical the ones like 117 that parse because of something we still need to fix in our grammar.

Guarani has free word order, but in the constructions of matrix yes-no questions, there is a requirement to put the question clitics in the second position. This means that different sentence elements can be positioned in the first position spot, giving them a special focus consideration. 

Here some examples that illustrate this sentence:

#Ex.122: Yes-No question with focus marker on verb predicate, and use of marker pa
Source: c
Vetted: f
Judgment: g
Phenomena: {q, wo}
ohechapa ñakyra vakápe?
ohecha pa nNakyra vakaA pe
o-hecha=pa nNakyra vakaA=pe
O.3-see=Q cricket.ANIM.NOM cow.ANIM=ACC
'Did the cricket see the cow?'

#Ex.123: Yes-No question with focus marker on subject
Source: c
Vetted: f
Judgment: g
Phenomena: {q, wo}
ñakyrapa ohecha vakápe?
nNakyra pa ohecha vakaA pe
nNakyra=pa o-hecha vakaA=pe
cricket.ANIM.NOM=Q O.3-see cow.ANIM=ACC
'Was it the cricket, who saw the cow?'

#Ex.124: Yes-No question with focus marker on verb object
Source: c
Vetted: f
Judgment: g
Phenomena: {q, wo}
vakápepa ohecha ñakyra?
vakaA pe pa ohecha nNakyra
vakaA=pe=pa o-hecha nNakyra
cow.ANIM=ACC=Q O.3-see cricket.ANIM.NOM
'Is it the cow, that the cricket saw?’

Currently in our grammar, IGTs 122 and 123 will parse, but not IGT #124.  The accusative marker =pe is taking middle position between first position noun and question marker =pa, therefore the second position not available for the clitic. This was not implemented in our grammar. 

The implementation of this phenomena involved several changes in our grammar.

As the marker for YN matrix questions in Guarani requires to be in the second position. It was important to identify a feature, that would able to mark the position of the words at the extreme left of the sentence. The feature [L-PERIPH bool] was used for that purpose. The feature is passed already through the binary and unary phrase rules of the grammar between mother and (left-side) daughter, and marks for binary rules the right-side daughter as negative. This feature did not have to be implemented by ourselves.

For the head-mod-phrase-simple and  we needed an addendum:

	basic-head-mod-phrase-simple :+ 
   		[ SYNSEM.LOCAL.CAT.MC #mc,  
     		  NON-HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD.MOD < [ L-PERIPH #periph ] >,
				     MC #mc ],
     		  HEAD-DTR.SYNSEM.L-PERIPH #periph ].


We decided to implement the question markers (=pa/=piko) as adj clitics, and created a especial lexical type for it:

       question-clitic-lex := no-hcons-lex-item &
  			[ SYNSEM [ LOCAL [ CAT [ IC +, 
                                           VAL [ SPR < >, 
						 COMPS < >, 
						 SUBJ < >, 
						 SPEC < >],
                                           HEAD	 adj & 
						[ MOD < [ LIGHT +,
							L-PERIPH +,
				                       	LOCAL intersective-mod] > ]],
                                          CONT.RELS <! !> ],
                                 NON-LOCAL.YNQ <! *top* !>  ]].

The clitic is allowed only to have a modifier, which has to be [LIGHT +, LOCAL intersective-mod]. The MOD is not of a particular word category, so that any sentence component can be focal point of a yes-no-question. The MOD element has also to have [L-PERIPH +], which allows the clitic to be in second positions. Additionally we implemented the feature IC (for interrogative clause), which as explained in the next section, allows it to combine with main clause verbs to form embedded interrogative clauses. 

We added two clitics to the lexicon:

	pa := question-clitic-lex   &
    		[STEM <"pa">].

	piko:= question-clitic-lex &
    		[STEM<"piko">].

To address the semantics of these sentences that required to identify to a feature value of [SF ques], a feature YNQ was created, that would register the presence of a question clitic in a non-local feature, which is accumulated from the daughters. 

	non-local:= [YNQ 0-1-dlist]

It was not enough to put a non-empty YNQ value in the clitic, but other words have to have an empty YNQ value. This is done with this:

	non-ynq-word := lex-item &
  			[ SYNSEM.NON-LOCAL.YNQ 0-dlist ].
	basic-zero-arg :+ [ SYNSEM.NON-LOCAL.YNQ 0-dlist ].
	basic-one-arg :+ [ SYNSEM.NON-LOCAL.YNQ 0-dlist ].
	basic-two-arg :+ [ SYNSEM.NON-LOCAL.YNQ 0-dlist ].
	basic-three-arg :+ [ SYNSEM.NON-LOCAL.YNQ 0-dlist ].
	intersective-mod-lex :+ [ SYNSEM.NON-LOCAL.YNQ 0-dlist ].


We constrained binary phrases to gather up YNQ from both daughters, for which we put an addendum to the basic-binary-phrase:

	basic-binary-phrase:+
	 [ SYNSEM [ L-PERIPH #periph,
                    NON-LOCAL.YNQ [ LIST #list, 
				    LAST #last ] ],
	   ARGS < [ SYNSEM [ L-PERIPH #periph,
                    	     NON-LOCAL.YNQ [ LIST #list, 
					     LAST #middle ] ] ],
        	  [ SYNSEM [ L-PERIPH -,
               		      NON-LOCAL.YNQ [ LIST #middle, 
					      LAST #last ] ] ] > ].

We constrained some unary phrases (bare-np, opt-subj, and opt-subj) to copy up these YNQ list, by adding this phrase rule :

	same-ynq-unary-phrase := unary-phrase &
  		[ SYNSEM.NON-LOCAL.YNQ #ynq,
    		  ARGS < [ SYNSEM.NON-LOCAL.YNQ #ynq ] > ].


Also the root symbol was constrained to require an empty YNQ value:

	root := phrase &
  		[ SYNSEM [ LOCAL [ COORD -, 
				   CAT [ HEAD +vj,
					 VAL [  SUBJ < >, 
					 	COMPS < > ],
                                   	 MC +,
				   	 EC-]],
           		   NON-LOCAL.YNQ 0-dlist ]].

Then we created a non-branching rule (int-cl) which empties the YNQ list and returns [L-PERIPH] to be underspecified, so that clitics can appear in embedded clauses. 

	int-cl := head-only-int-decl-clause & interrogative-clause &
  		[ SYNSEM [ LOCAL.CAT [  VAL #val & [ SUBJ< >, 
						    COMPS< >, 
						    SPR< >], 
					MC bool, 
					IC +],
             		   NON-LOCAL.YNQ <! !> ],
    		  HEAD-DTR.SYNSEM [ LOCAL.CAT [ IC +, 
						MC na, 
						VAL #val, 
						HEAD verb],
                    	   	    NON-LOCAL.YNQ <! *top* !> ]].


This rule has a MC bool value, that allows it to unify with the root. Also it empties the YNQ list, which is also required by the root. The rest of the nodes below it have [MC na], so that the compatibility is guaranteed. It collects the IC boolean value for embedded interrogative clauses from the daughter (further below for this).

This rule was included in rules.tdl so that the YN question could be link to the root and generate a parses according to their specified rules.:

	int-cl:= int-cl.

To constrain other headed phrases to produce [MC na] mothers and daughters, this rule was included:

	mc-na-headed-phrase := headed-phrase &
  		[ SYNSEM.LOCAL.CAT.MC na,
    		  HEAD-DTR.SYNSEM.LOCAL.CAT.MC na ].

There is a new super type head-only-int-decl-clause. This supertype was constructed based on a supertype that was only existent in the matrix.tdl file (therefore untouchable).The original supertype head-only (actually its supertype basic-unary-phrase) restricted the passing of the [L-PERIPH] feature in a strict way through the unary rules (among other things). In the case of an embedded sentence, head-only would have not allowed a ‘second position’ clitic inside the sentence in the presence of a main clause verb that pushed the positions of the embedded words further down in the hierarchy. While other rules where allowed to unify with head-only, int-cl (and decl-cl) inherited from head-only-int-decl-clause, which involved these changes:

	basic-unary-int-decl-cl-phrase := phrase &
  	      [ STEM #stem,
    		SYNSEM [ LOCAL [ CAT.MKG #mkg,
		     		 CONT [ RELS [  LIST #first,
					   	LAST #last ],
			    	 	HCONS [ LIST #scfirst,
					 	LAST #sclast ],
			    		ICONS [ LIST #icfirst,
					    	LAST #iclast ] ] ] ],
    				C-CONT [ RELS [ LIST #middle,
				    		LAST #last ],
	     				HCONS [ LIST #scmiddle,
		     				LAST #sclast ],
	     				ICONS [ LIST #icmiddle,
			     			LAST #iclast ] ],
    		ARGS < sign & [ STEM #stem,
			    	SYNSEM [ LOCAL  local &
			      			[ CAT.MKG #mkg,
						  CONT [ RELS [ LIST #first,
					      			LAST #middle ],
				       			HCONS [ LIST #scfirst,
					       		LAST #scmiddle ],
				       			ICONS [ LIST #icfirst,
					       		LAST #icmiddle ] ] ] ] ] > ].

	unary-int-decl-cl-phrase := basic-unary-int-decl-cl-phrase &
  		[ INFLECTED infl-satisfied,
    		  ARGS < [ INFLECTED infl-satisfied ] > ].

	head-only-int-decl-clause := unary-int-decl-cl-phrase & headed-phrase &
  		[ HEAD-DTR #head,
    		  ARGS < #head > ].


To avoid ambiguity the following restriction was added:
		
		bare-np-phrase:+ [SYNSEM.LIGHT -]

	s-coord-phrase :+
  	[ SYNSEM.LOCAL.CAT [ MC bool, 
			     EC #ec, 
                             IC #ic],
    	  LCOORD-DTR.SYNSEM.LOCAL.CAT [ MC bool, 
					EC #ec,  
					IC #ic],
     	  RCOORD-DTR.SYNSEM.LOCAL.CAT [ MC bool, 
					EC #ec,  
					IC #ic]].

 	s-bottom-coord-phrase :+
   	[ SYNSEM.LOCAL.CAT [ MC bool, 
			     EC #ec, 
			     IC #ic ],
         NONCONJ-DTR.SYNSEM.LOCAL.CAT [ MC bool, 
					EC #ec, 
					IC #ic ] ].

We were able to implement the analysis with single-word NP (without case marks) and VP arguments for the predicate, as well as dropped arguments. We were not able to implement the analysis when the first word in a yes-no-question sentence was a multi-word NP or marked with an apposition that was modeled as a clitic (e.g. the accusative marker =pe). The clitics and the multi-word NPs would move the question clitics out of the 2nd position, which our grammar was not able to recognize at this time.  

Here are some thoughts for a possible solution: The appositions and other nouns would have to copy the [L-PERIPH] value of its first left argument argument, either lexical rule, or other rules.

Also something not implemented in this section, was the focal aspect of question markers. A yes-no-question in Guarani involves also the focus of a sentence constituent. This kind of structural information are out of focus and are not dealt with further here. 


2. Embedded Clauses (interrogative and declarative)

Guarani uses suffixes for embedded clauses.  Like many languages it distinguishes between declarative and interrogative embedded clauses.


2.1. Embedded Clauses (interrogative)

I. A descriptive statement of the facts of your language. 

There are certain verbs is Guarani that take questions as complements. These are verbs that inquire something or express doubts. We found that the Guarani verb ‘ask’ allows this kind of construction. 

The embedded interrogative clause follows the same patters as the matrix yes-no questions, and therefore we can build over the work of using the second position question markers inside of the interrogative clause to distinguish a first position element, which is in focus for the question.

Also, the free word order might allow for sentences, where the embedded clause is embedded
in different parts of the sentence, although we could attest in our test suite only sentences where the embedded sentence was after the main clause. We allow free word order as this is consistent with the situation in other transitive verbs of this language.

Here some example of an embedded interrogative sentence:


#Ex.150: Use embedded clause for interrogative sentence
Source: e
Vetted: f
Judgment: g
Phenomena: {emb-q, wo}
aporandu oupa
aporandu oju pa
a-porandu o-ju=pa
A.1SG-ask A.3-go=Q
'I ask whether he comes'

#Ex.149: Wrong marker for embedding of interrogative clause
Source: e
Vetted: f
Judgment: u
Phenomena: emb-q
aporandu ouha
aporandu ojuha
a-porandu o-ju-ha
A.1SG-ask A.3-go-COMP
*'I ask whether he comes'


#Ex.196: NP predicate, possessive marking
Source: author
Vetted: f
Judgment: g
Phenomena: emb-q
aporandu ohechapa ju'ipe
aporandu ohecha pa juHi pe
a-porandu o-hecha=pa juHi=pe
A.1SG-know A.3-see=COMPL frog=ACC
'I ask if somebody sees the frog'

#Ex.197: Embedding of interrogative clause
Source: author
Vetted: f
Judgment: g
Phenomena: emb-q
aporandu ohechapa ju'i
aporandu ohecha pa juHi
a-porandu o-hecha=pa juHi=pe
A.1SG-know A.3-see=COMPL frog=ACC
'I ask if somebody sees the frog' / 'I ask if the frog sees it'


The implementation built over the implementation of previous matrix yes-no questions, which are the embedded complements.

For that purpose we created a super type, that we would use for interrogative clause complement verbs and declarative clause complement verbs, and let that type be inherited by the lexical entry (e.g. int-cl-verb-lex is the type for ’ask’):

	cl-verb-lex:= gug-dyn-loc-verb &  clausal-second-arg-trans-lex-item &
    		[SYNSEM.LOCAL.CAT.VAL.COMPS <#comps>,
     		 ARG-ST.REST.FIRST #comps].

 	int-cl-verb-lex:= cl-verb-lex &
    		[SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT [ IC +,
                                                              HEAD verb,
					                      VAL [ COMPS < >, 
                                                                    SUBJ < > ] ],
				 			CONT.HOOK.INDEX.SF ques ]]>].

The complement clause had to be a verb, with [SF ques] value, as this is a question clause. Additionally, the complement needs to have [IC +] which is a boolean value we introduced to keep track of presence or absence of the question-clitic element.

		cat :+ [EC bool, IC bool].


This feature helps us to define an embedded clause as an interrogative clause. The other feature [EC bool] was employed for the declarative clause implementation, which is explained further in the next section.

Here the question clitic as it was implemented:

    question-clitic-lex := no-hcons-lex-item &
	[ SYNSEM [ LOCAL [ CAT [IC +, 
				HEAD adj & [ MOD < [ LIGHT +,
						      L-PERIPH +,
				                      LOCAL intersective-mod] > ],
				VAL [ SPR < >, 
				      COMPS < >, 
                                      SUBJ < >, 
                                      SPEC < > ]],
                           CONT.RELS <! !> ],
                   NON-LOCAL.YNQ <! *top* !>  ]].

The head-adj-phrase that fires when the clitic attaches copies that value up in the parse tree.

	head-adj-int-phrase :+ 
    	      [ SYNSEM.LOCAL.CAT [ EC #ec, 
                    		   IC #ic ],
     		NON-HEAD-DTR.SYNSEM.LOCAL.CAT [ EC #ec,
                         		        IC #ic ]].

This feature value is also copied up the parse through a unary rule that was appended to head-subj-opt, head-opt-comp and the bare-np-rule. 

	same-ec-unary-phrase := headed-phrase &
  		[ SYNSEM.LOCAL.CAT [ EC #ec,
                       		     IC #ic],
    		  HEAD-DT.SYNSEM.LOCAL.CAT [ EC #ec,
                         		     IC #ic ] ].

Additionally the following binary rule addendum let the feature percolate through the binary branches:


	basic-head-comp-phrase :+ [ SYNSEM.LOCAL.CAT [ EC #ec, 
        	                                       IC #ic ],
                            	    HEAD-DTR.SYNSEM.LOCAL.CAT [ EC #ec,
                                                       		IC #ic ]].

	basic-head-subj-phrase :+ [  SYNSEM.LOCAL.CAT [ EC #ec, 
                                               		IC #ic ],
                            	     HEAD-DTR.SYNSEM.LOCAL.CAT [EC #ec,
                                                       		IC #ic ]].

	basic-head-opt-comp-phrase :+
 				[ SYNSEM [ L-PERIPH #periph,
            				   LOCAL.CAT [ EC #ec,
                        			       IC #ic ]],
            			  ARGS < [ SYNSEM [ L-PERIPH #periph, 
                              			    LOCAL.CAT [ EC #ec,
                                      	    			IC #ic  ] ] ] > ].

The feature worked also in conjunction with the value definition for verbs. Verb lexemes had the feature defined as [IC -]:

	trans-verb-lex:+ [SYNSEM.LOCAL.CAT [EC -,
        	                            IC -]].
	intrans-verb-lex: + [SYNSEM.LOCAL.CAT [EC -,
        	                               IC - ]].

So if the question clitic was not present in the clause (as we had in some of our wrong parses), the IC value of the of the verb predicate would percolate up, and not unify with the [IC +] requirement of the int-cl rule. This would not happen with stand-alone interrogative clauses, as the question clitic is by definition part of the whole clause. This was the main reason of the implementation of this clitic. We had initially thought of trying to leverage the MC value, but found it better to leave it untouched, because even though the phenomena is not the same because unlike =ha, =pa does appear in matrix-clause-questions, and so it would be wrong to say it was restricted to embedded clauses.

Here are the int-rule and the int-co-verb-lex again that instantiate the embedded interrogative clause:

	int-cl := head-only-int-decl-clause & interrogative-clause &
  		[ SYNSEM [ LOCAL.CAT [ VAL #val & [ SUBJ< >, 
						    COMPS< >, 
						    SPR< >], 
					MC bool, 
					IC +],
             		   NON-LOCAL.YNQ <! !> ],
    		HEAD-DTR.SYNSEM [ LOCAL.CAT [ IC +, 
					      MC na,
					      HEAD verb,
					      VAL #val],
                    	   NON-LOCAL.YNQ <! *top* !> ]].


 	int-cl-verb-lex:= cl-verb-lex &
    		[SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT [ IC +,
                                                              HEAD verb,
					                      VAL [ COMPS < >, 
                                                                    SUBJ < > ] ],
				 			CONT.HOOK.INDEX.SF ques ]]>].

The verb lexical type will unify with the interrogative clause only if the interrogative clause inherited [IC +] from its parses, which happens then the question-clitics attaches correctly to the clause. 

We checked a standard sentence in our implementation, using single noun arguments.

#Ex.201: Embedding of interrogative clause
Source: e
Vetted: f
Judgment: g
Phenomena: emb-q
aporandu ohechapa ju'i vakaA
aporandu ohecha pa juHi vakaA
a-porandu o-hecha=pa juHi vakaA
A.1SG-ask A.3-see=COMPL frog cow
'I ask if somebody sees the frog's cow'/ ' I ask if the frog's cow sees it' / 'I ask if the frog sees the cow' / 'I ask if the cow sees the frog'

 We had around 10 parses, most due to our coordination rule and reading of noun phrases as independent noun predicates. Those readings were not in our area of interest. 

We detected that our implementation was able to generate declaration clauses at the top root, but not interrogative clauses, which is separate from the embedded clause, which worked well. The unification error showed that YNQ lists were not emptied by our int-cl rule. With further time, it is an improvement to happen, and potentially something we could check the next weeks. Nevertheless the basic functionality to generate sentences with interrogative embedded clauses did succeed.

As mentioned in the previous sections there were some limitations to this implementation, which were related to the number of words that occupy the first position of the embedded clause (e.g., our =pe examples above). Potentially we should be able to able to increase this capability in the coming weeks, if time allows.


2.2. Embedded Clauses (declarative)

In Guarani, there are verb predicates that allow declarative sentences to be their complements. These verbs assert, confirm or share knowledge. One of those verbs is ‘to know’, which allows therefore an embedded declarative clause. The embedded clause has a similar construction as the yes-no-questions, but with a different marker. This marker, a complementizer =ha, is also in the second position of the declarative clause, but the first element of the declarative clause has to be the verb predicate of that clause. Therefore this marker doesn’t have the focal function as in the =pa/=piko marker of yes-no-questions.

Here some examples with the use and misuse of such embedded declarative sentences:

#Ex.148: Use embedded clause for declarative sentence
Source: e
Vetted: f
Judgment: g
Phenomena: {emb-d, wo}
aikuua ouha
aikuua oju ha
a-ikuua o-ju=ha
A.1SG-know A.3-come=COMPL
'I know he comes'

#Ex.149: Wrong marker for embedding of interrogative clause
Source: e
Vetted: f
Judgment: u
Phenomena: emb-q
aporandu ouha
aporandu oju ha
a-porandu o-ju=ha
A.1SG-ask A.3-go=COMPL
*'I ask whether he comes'

#Ex.150: Use embedded clause for interrogative sentence
Source: e
Vetted: f
Judgment: g
Phenomena: {emb-q, wo}
aporandu oupa
aporandu oju pa
a-porandu o-ju=pa
A.1SG-ask A.3-go=Q
'I ask whether he comes'

#Ex.198: Use embedded clause for declarative sentence
Source: author
Vetted: f
Judgment: g
Phenomena: {emb-d, wo}
aikuua ohechaha ju'ipe
aikuua ohecha ha juHi pe
a-ikuua o-hecha=ha juHi=pe
A.1SG-know A.3-go=COMPL juHi=ACC
'I know he/she/it sees the frog'

#Ex.199: Use embedded clause for declarative sentence
Source: author
Vetted: f
Judgment: g
Phenomena: {emb-d, wo}
aikuua ohechaha ju'ipe
aikuua ohecha ha juHi
a-ikuua o-hecha=ha juHi
A.1SG-know A.3-go=COMPL juHi
'I know he/she/it sees the frog' / 'I know the frog sees it'


For the implementation of this phenomenon, we had to create a verb-lexeme, that is a subtype to the previously mentioned super type cl-verb-lex:

	decl-cl-verb-lex:= cl-verb-lex &
    			[ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT [ EC +,
                       		                                IC -,
 					                                HEAD verb,
					                                VAL.COMPS < > ],
			    				 CONT.HOOK.INDEX.SF prop ]]>].

The main verb requires the clause to be exclusively embedding ([EC +]), not an interrogative clause ([IC-]), and it go be a sentence  (therefore the HEAD verb for the complement). The semantic is to be a embedded clause have to express a proposition ([SF prop]).

The rule the license the embedded clause is the following:

 	decl-cl := head-only-int-decl-clause & declarative-clause & 
  		[ SYNSEM.LOCAL.CAT [ VAL #val & [SUBJ< >, COMPS< >, SPR< >], MC bool, EC #ec, IC #ic],
    		  HEAD-DTR.SYNSEM [ LOCAL.CAT [ MC na, VAL #val, HEAD verb, EC #ec, IC #ic],
                     NON-LOCAL.YNQ 0-dlist ]].

As mentioned in the previous section, we introduced a new feature [EC bool]. This feature checkes if a sentence is an exclusively embedding sentence. In order to unify with the requirements of the decl-co-verb-lex, [EC] has to be [EC +]. Similarly [IC -]. These value is introduced the the complementizer-clitic:

	compl-clitic-lex := no-hcons-lex-item &
 			[ SYNSEM [ LOCAL [ CAT [ IC -, 
                       			   EC +,
                          VAL [ SPR < >, COMPS < >, SUBJ < >, SPEC < >],
                          HEAD adj & [ MOD < [LOCAL.CAT.HEAD verb,
                                              LIGHT +,
                                              L-PERIPH +,
                                              LOCAL intersective-mod ] > ]],
                    CONT.RELS <! !> ]]].

The values are copied into the parse by the head-ada-phrase rule, which was mentioned in the previous section about interrogative clauses. The clitic requires to have a second position, and being attached as a modifier to a verb word, or it will not unify. The mechanics are similar to the one employed with the interrogative clauses, just with he additional EC feature. By definition, verbs have a [EC -], so only the proper attachment with the complementizer clitic guarantees that the unification of the embedded clause with the main clause verb works.

We experimented the parsing with single noun arguments.


#Ex.202: Embedding of interrogative clause
Source: e
Vetted: f
Judgment: g
Phenomena: emb-d
aikuua ohechaha ju'i vakaA
aikuua ohecha ha juHi vakaA
a-ikuua o-hecha=ha juHi vakaA
A.1SG-know A.3-see=COMPL frog cow
'I know that somebody sees the frog's cow' / ' I know that the frog's cow sees it' / 'I know that the frog sees the cow' / 'I know that the cow sees the frog'

Ignoring the parses generated by the coordination rules, we were satisfied with  the results. This embedded declarative construction was also able to construct int-cl and decl-cl versions for each of the possible parses. 

Nevertheless there are limitations. As mentioned before, the grammar is not able to handle constituents in the first position that are made of more than one word (which might include complex nouns made of nouns in juxtaposition, as well as case markings). This is something that could be addressed when time and workload allows it.


3. Non-verbal predicates (NP, PP, AP)


3.1 Adjective

As mentioned in a previous lab (lab 4), PG has attributive and predicative use of adjectives. In predicative form, the adjective receives verbal inflection and the noun it “modifies” acts as its subject. Adjectives behave in this form as stative-intransitive-verbs, and the cross-markers refer to the subject exclusively using the O-group of markers (patient markers). The different use of attributive and predicative adjectives is illustrated in the following IGT examples.

#Ex.136: Use of adjective as an attribute of the subject of a verb predicate
Source: author
Vetted: f
Judgment: g
Phenomena: {adj, wo}
jagua ñarope ahendu
jagua nNaro pe ahendu
jagua nNaro=pe a-hendu
dog.ANIM angry=ACC A.1SG-hear
'I hear the angry dog'

#Ex.137: Attributive adjective should not have predicate markings 
Source: author
Vetted: f
Judgment: u
Phenomena: adj
jagua iñarope ahendu
jagua inNaro pe ahendu
jagua i-nNaro=pe a-hendu
dog.ANIM O.3-angry=ACC A.1SG-hear
*'I hear the angry dog'

#Ex.138: Use of adjective as a predicate
Source: b
Vetted: f
Judgment: g
Phenomena: cop
jagua iñaro
jagua inNaro
jagua i-nNaro
dog.ANIM O.3-angry
'The dog is angry'

The implementation followed creating extra lexical entries for the predicative adjectives as stative-intransitive verbs, letting them follow our already stablished grammar for their behavior. In difference to other verb predicates, the semantic predicates are marked as ‘_a_rel’ instead of ‘_v_rel’. Here an example of a lexical entry as used for the previous IGT examples: 

	nNaro_1 := stative-intrans-verb-lex &
  		[ STEM < "nNaro" >,
    		SYNSEM.LKEYS.KEYREL.PRED "_angry_a_rel" ].

Additive predicates work in our expected way. We have not had time to experiment the combinations that this phenomenon might have with other features, as our test suite is mostly tailored towards sentences that check single phenomena. Nevertheless we expect, that this and other rules might have to be adjusted to operate in conjunction.


3.2 Noun

Our original analysis of PG, suggested that noun predicates are present exclusively through the use of cross-markers, similar to the way cross-markers are used with stative-intransitive verbs:

#Ex.139: Use of noun predicate
Source: b
Vetted: f
Judgment: g
Phenomena: cop
chesy
chesy
che-sy
O.1SG-mother.ANIM
'I am a mother'/‘There is my mother’

#Ex.142: NP Predicate, Possessive marking. Aspect marking (not currently handled by our grammar).
Source: f
Vetted: f
Judgment: g
Phenomena: cop
hi'árama
iaArama
i-aAra-ma
POSS.3-day-PERF
'It is his/her day already' 

These noun predicates take markings like subject markers and other aspect markers, especially as shown in IGT 142.There are also additional noun predication that can have other meanings like a semantic of ‘_have_rel’, which are not shown here. These noun predications are outside of scope for our current analysis and will not treated here.
Nevertheless, IGT# 139 showed also the existence of an additional type of noun predication, with the semantics of ‘There is my mother. This suggests the existence of zero-copula noun predicates:

#Ex.200: Nominal predicate. Contentful postposition modifier.
Source: author
Vetted: f
Judgment: g
Phenomena: {cop, adp}
jagua jaguandi
jagua jagua ndi
jagua jagua=ndi
dog.PRED dog=with
'There is a dog with a dog'

We implemented this kind of noun predicates with a new type of rule:

n-bar-predicate-rule := unary-phrase & nocoord &
  [ SYNSEM.LOCAL [ AGR #agr3,
                   CAT [ MC na,
                        HEAD verb & [MOD < >],
                        VAL [ SPEC < >,
                              SPR  < >,
                              COMPS < >,
           SUBJ < [ LOCAL [ CONT.HOOK.INDEX #arg1,
                CAT [ HEAD noun,
                      VAL.SPR < > ] ] ] > ] ]],
    C-CONT [ HOOK [ LTOP #ltop,
        INDEX #index,
        XARG #arg1 ],
       RELS <! arg12-ev-relation &
       [ PRED "_be_v_id_rel",
         LBL #ltop,
         ARG0 #index,
         ARG1 #arg1,
         ARG2 #arg2 ],
       quant-relation &
       [ PRED "exist_q_rel",
         ARG0 #arg2,
         RSTR #harg ] !>,
       HCONS <! qeq & [ HARG #harg, LARG #larg ] !> ],
    ARGS < [ SYNSEM.LOCAL [ AGR #agr3,
                            CAT [ HEAD noun & [POSS poss-or-eel],
                            VAL.SPR cons ],
          CONT.HOOK [ INDEX #arg2,
          LTOP #larg ]]] > ].

We see that this unary rule, that extends over noun phrases, adds the predication ‘of to be’. The rule was added to the rule.tdl file, in order to instantiate these predicates. The rules requires the argument to be a noun, but with a restriction [POSS poss-or-eell], which means that pronouns are not acceptable.
Our implementation works satisfactorily for our goals here. It generates in all other kind of phenomena of our grammar additional sentence parses, as each individual noun could be also interpreted as a separate noun predicate, which combined with our sentential juxtaposition can multiply the number of interpretations. This result is allowed in this grammar.
Something that we were not able to implement in this grammar, is to allow our noun predicates to have markers, like the cross-reference markers with other arguments, as well as possibly combinations with other aspect markers. We leave this for another time.


3.3 Prepositions

In Guarani, our analysis indicates that prepositional phrases work with conttentful appositions that add significant meaning to a sentence. 
These appositions usually interact with different kind of predicates, some of them with full semantic content, so that the appositions work more as a modifier:

#Ex.166: Contentful postpositions  
Source: author
Vetted: f
Judgment: g
Phenomena: adp
oiju mombyrý-vi 
oju mombyryA gui 
o-ju mombyryA=gui
3.ACT-come far=from
'He/she comes from far(a far place)' 

Similarly in the case of noun predicates, which we have analyzed as zero-copulas, the prepositional phrases act also as a modifier:

#Ex.200: Nominal predicate. Contentful postposition modifier.
Source: author
Vetted: f
Judgment: g
Phenomena: {cop, adp}
jagua jaguandi
jagua jagua ndi
jagua jagua=ndi
dog.PRED dog=with
'There is a dog with a dog'

In other cases these appositions interact with raising verbs, which are not-fully semantically bleached. These are verbs with a similar meaning as ‘to-be-located’. 

#Ex.164: be+located raising verb. Contentful postpositions.  
Source: b
Vetted: f
Judgment: g
Phenomena: {cop, adp}
Oime kotýpe jaguandi
oime koty pe jagua ndi
o-ime koty=pe jagua=ndi
3.ACT-be.located room=in dog=with
'He/She is located in the room with the dog'

For this kind of verbs we implemented a new type verb-lexeme, that would take the prepositional phrases as a complement:


locative-verb-lex := gug-dyn-loc-verb & trans-first-arg-control-lex-item &
  [ SYNSEM.LOCAL [ CAT.VAL [ SUBJ < #subj >,
                             COMPS < #comps >,
                             SPR < >,
                             SPEC < >   ],
                   CONT.HOOK.XARG #xarg ],
    ARG-ST < #subj &
             [ LOCAL [ CONT.HOOK.INDEX #xarg,
                       CAT [ HEAD noun, 
                             VAL [ SPR < >,
                                   COMPS < > ],
                             HEAD noun ] ] ],
             #comps &
             [ 	OPT -,
		LOCAL.CAT [ VAL [ COMPS < > ],
                           HEAD adp & [CASE LOC] ] ] > ].

This type takes the cross-markings of agents in dynamic verbs. Additionally is first argument is a noun phrase, and its second argument a contentfull adposition which identifies with the locative case.

We added also the entry in the lexicon for our non-semantically bleached raising verb, which has a similar use like the Spanish verb ‘star’, close to ‘be+located’ in English:

ime := locative-verb-lex &
  [ STEM < "ime" >,
    SYNSEM.LKEYS.KEYREL.PRED "_be+located_v_rel" ].

Additionally, also the lexical entries for our contentful appositions:

pe2 := contentful-adp-lex & 
  [ STEM < "pe" >,
    SYNSEM.LKEYS.KEYREL.PRED "_in_p_rel" ].

gui := contentful-adp-lex & 
  [ STEM < "gui" >,
    SYNSEM.LKEYS.KEYREL.PRED "_from_p_rel" ].

ndi := contentful-adp-lex & 
  [ STEM < "ndi" >,
    SYNSEM.LKEYS.KEYREL.PRED "_with_p_rel" ].

which are linked to our grammar through the contentful-adp-lex type:

contentful-adp-lex := basic-int-mod-adposition-lex
[ SYNSEM.LOCAL.CAT [ HEAD adp & [CASE LOC,
                                 MOD <[ LOCAL.CAT[ MC na, 
                                                   HEAD verb,
                                                   VAL [SUBJ < >]],
                                        L-PERIPH +] > ],
                       VAL [ SPR < >,
                             COMPS < #comps >,
                             SPEC < >, 
                             SUBJ < > ]  ],
    ARG-ST < #comps & [ OPT -,
                        LOCAL.CAT[ HEAD +np,
                                   VAL [SPR < >] ] ] > ].

This lexical type then unifies with other elements of a sentence forming prepositional phrases that are either modifiers (like in the first two IGTs shown here) as a contentful complement of locative verbs.

There are some aspects of our implementation that don’t reflect the full reality of prepositional predicates. They currently act as modifiers or complements of verbal and noun predicates. They can though also be complements of noun phrases that do not need to be predicative. This is not what our grammar does. This would require to change the MOD value of our locative adpositions. We leave this idea for a future intend, when time and workload allows for it.


4. Anything else.
Guarani has ditransitive verbs, and there are several examples present in our test suite. It seems that its implementation is not planned during this course. Nevertheless we gathered some information about its possible implementation, which hopefully will be possible when the workload allows it.
There is a ditransitive-verb-item, that needs to combine with the verb supertype, which allows us to build a ditransitive verb type. Our first attempt looks as follows:

	ditransitive-verb-lex := verb-lex & ditransitive-lex-item & 
                          completive-aspect-or-perfective-aspect-or-prospective-aspect-rule-dtr & 
                          future-aspect-rule-dtr & neg1-rule-dtr & neg2-rule-dtr &
  		[ SYNSEM.LOCAL.CAT.VAL.COMPS < #comps1 & [OPT-CS in-foc], #comps2 & [OPT-CS in-foc]>,
    			ARG-ST <[LOCAL.CAT.HEAD +np],
    			#comps1 & [LOCAL.CAT [VAL [SPR<>, COMPS<>],
                          		HEAD [+np, CASE ACC]],
                    	#comps2 & [LOCAL.CAT [ VAL [ SPR < >, COMPS < > ],
                                      HEAD [+np, CASE DAT] ] ] >,
    		  INFLECTED.PERNUM-TRANS-FLAG - ].

We recorded also the possible lexicon entries for our ditransitive verbs:

		hechauka := ditransitive-lex-item &
   			[STEM<"hechauka">,
    	  		 SYNSEM.LKEYS.KEYREL.PRED "_show_v_rel"].

 		meHeN := ditransitive-lex-item &
   			[STEM<"meHeN">,
    		         SYNSEM.LKEYS.KEYREL.PRED "_give_v_rel"].

The ditransitive uses also the marker =pe for [CASE dat] arguments, but different to similar looking accusative marker, the dative marker is in those cases obligatory. This means that we will have to implement this as a different =pe.


5. Statement of the current overage of the grammar over your testsuite (using number you can get from Analyze|Coverage and Analyze|Overgeneration in [incr tsdb()]) and a comparison between your baseline testsuite run and your final one for this lab (see Compare|Competence).
